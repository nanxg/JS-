[toc]

# 变量提升，作用域，闭包

## 变量提升

- JS引擎会一开始会解析全局作用域中所有var的变量(初始为undifined)和function（解析，但不赋值，不执行，不打印输出）
- 通过函数覆盖undefined，还有后面的函数会把前面的函数覆盖，函数覆盖赋值的原则，进行变量值最后的确认（函数大于所有，里域大于外域）
- 逐行解读代码：读打印、输出、赋值

## 作用域(scopes)

域：范围，JS执行的环境

- 全局作用域（window执行栈）
	- 如果有多个script标签，上一个script标签报错不影响下一个script标签代码执行
	- 查找方式：先看当前script标签内，没有的话去上一个script标签中找，如果没有就报错（不影响下一个script标签代码执行）
- 局部作用域（函数执行栈）
	- 块级作用域
	- 函数执行时单独开辟一个执行栈，把函数中存的字符串在这个执行栈中运行
		- 1.形参赋值，2.变量提升，3.执行上下文，4.执行栈销毁。
	- 如果局部作用域中没有变量、函数、形参的时候，会逐层向域外查找，直到window为止
	- 如果局部作用域中有变量，会在域内直接找，不去域外，即使这个变量在下方声明（解析时会解析到）。
	- 如果局部作用域中有变量和形参，会优先形参（形参在最上边赋值实参）。
	- 如果局部作用域中有函数、变量和形参，会优先域内函数
	
## this

- 全局this：window
```
console.log(this); //window
fn(); //window
//包括自执行函数中的this
//定时器
```

- 事件this：事件触发的对象
```
box.onclick=function(){
	console.log(this); //box
}
```

- 对象下的this：指向.前面的对象/属性
```
obj = {
   style:{
        fn:function(){
            console.log(this);
        }
    }
}
obj.style.fn()  //this => obj.style
```

- 实例
```
构造函数下的this是实例
构造函数原型下的this是也是实例（需实例调用）
```

- 箭头函数
```
与声明箭头函数的上下文的this相同
箭头函数没有arrigurments，不能new
```

## 闭包运行机制

### 闭包(closure)

- 定义
	- w3cschool上：一个函数访问外部变量，这个函数就叫闭包。（不准确）
- 作用：存储变量或参数，易于累积计算
	- 可能导致栈溢出，解决办法：用完变量就释放它（手动赋值为null）

- 闭包：
	1. 函数嵌套函数，
	2. 子函数引用父函数的参数或变量，
	3. 子函数被外界所引用，
	4. 父级就形成了闭包环境，父级函数的参数或变量就不会被浏览器垃圾回收机制回收（执行栈不被销毁）
	5. 打印父级函数的返回值会发现scopes下有个closure，就是闭包
```
function fn(){
    var a=10;
    function fa(){
        a++
        console.log(a);
    }
    function f2(){}
    console.dir(f2);//也显示闭包，因为fn闭包
    return fa
}
var c=fn() //fn就形成了闭包环境,fn中的参数或者变量就不会被浏览器垃圾回收机制回收       
console.dir(c); //函数返回值，scopes下有个closure,就是闭包
```

